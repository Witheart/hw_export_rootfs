#!/bin/bash

function showhelp()
{
	echo -e "
	hw_export_rootfs </path/to/store> [-s <source_path>] [-t <ext4|btrfs>]

	参数说明：
	  </path/to/store>    指定镜像文件的存储路径
	  -s <source_path>    指定要打包的源目录（默认：/）
	  -t <ext4|btrfs>     指定镜像文件的文件系统类型（默认使用源文件系统类型）
	"
	exit -1
}

function prepare_rootfs()
{
	systemctl enable resize-helper.service > /dev/null 2>&1
	apt-get clean -y
}

function clead_target_rootfs()
{
	ROOT_DIR=$1
	rm -rf ${ROOT_DIR}/usr/share/doc/*
	rm -rf ${ROOT_DIR}/var/lib/apt/lists/*
	rm -rf ${ROOT_DIR}/tmp/*
	find ${ROOT_DIR}/usr/share/man/ -name "*.gz" -exec rm {} \;
	find ${ROOT_DIR}/var/log/ -type f -name "*.gz" -exec rm {} \;
	find ${ROOT_DIR}/var/log/ -type f -exec truncate -s 0 {} \;

    for item in $(ls ${ROOT_DIR}/media/ 2>/dev/null); do
        if id ${item} > /dev/null 2>&1
        then
            chown -R ${item}:${item} ${ROOT_DIR}/media/${item}
        fi
    done

    if [[ -L "${ROOT_DIR}/var/lib/docker" ]]
    then
        orig_dir=$(readlink "${ROOT_DIR}/var/lib/docker")
        if [[ ! -d ${ROOT_DIR}/${orig_dir} ]]
        then
            rm -rf "${ROOT_DIR}/var/lib/docker"
            rsync -aqx "${orig_dir}/" "${ROOT_DIR}/var/lib/docker"
        fi
    fi
}

function umount_img() {
	if mountpoint -q $TEMP_MOUNT_POINT; then
		umount $TEMP_MOUNT_POINT
	fi
	rm -rf $TEMP_MOUNT_POINT
}

function finish() {
	umount_img
	exit -1
}

[[ $UID -ne 0 ]] && echo -e "\033[31m should run as root \033[0m" && showhelp
[[ -n "$(which rsync)" ]] || { echo -e " rsync not found\n\033[31m apt install rsync \033[0m"; exit -1; }
[[ $# -lt 1 ]] && showhelp;

# 新增变量
SOURCE_PATH="/"
DEST_PATH=""
STORE_FS_TYPE=""

# 参数解析
while [[ $# -gt 0 ]]; do
	case $1 in
		-s)
			SOURCE_PATH=$2
			shift 2
			;;
		-t)
			STORE_FS_TYPE=$2
			shift 2
			;;
		*)
			DEST_PATH=$1
			shift
			;;
	esac
done

[[ -d $DEST_PATH ]] || { echo -e "\033[31m store path not exist \033[0m"; exit -1; }
[[ -d $SOURCE_PATH ]] || { echo -e "\033[31m source path $SOURCE_PATH does not exist or is not a directory \033[0m"; exit -1; }

PORT_OVERLAYROOT=false

ROOTFS_MOUNTPOINT="$SOURCE_PATH"

MEDIA_FS_TYPE=`df $DEST_PATH --output=fstype | awk 'NR==2 {print $1}'`
MEDIA_FREE_SPACE=`df $DEST_PATH -m --output=avail | awk 'NR==2 {print $1}'`

prepare_rootfs

if [[ $STORE_FS_TYPE == "" ]]; then
	if [[ $ROOTFS_MOUNTPOINT == "/" ]]; then
		ROOTFS_DEVICE=`findmnt -n -o SOURCE --target /`
		ROOTFS_TYPE=$(blkid -o value -s TYPE ${ROOTFS_DEVICE})
	else
		ROOTFS_TYPE=$(df -T $ROOTFS_MOUNTPOINT | awk 'NR==2 {print $2}')
	fi
	STORE_FS_TYPE=$ROOTFS_TYPE
fi

if [[ $STORE_FS_TYPE == "btrfs" ]]; then
	ROOTFS_SIZE=`btrfs filesystem usage -m $ROOTFS_MOUNTPOINT | grep "Device allocated" | awk '{print $3}'`
else
	ROOTFS_SIZE=`du -s -k $ROOTFS_MOUNTPOINT | awk '{print $1}'`
fi

IMAGE_SIZE=$((ROOTFS_SIZE>>10))
IMAGE_SIZE=$((IMAGE_SIZE+IMAGE_SIZE/10+300))
echo -e "MEDIA FREE SPACE SIZE \t $MEDIA_FREE_SPACE \t MBytes"
echo -e "EXPORT IMAGE SIZE \t $IMAGE_SIZE \t MBytes"

if [[ $MEDIA_FREE_SPACE -lt $IMAGE_SIZE ]]; then
    echo -e "\033[31m No enough free space on $DEST_PATH \033[0m"
	exit -1
fi

CURDATE=`date "+%Y%m%d%H%M"`
OS_D=`lsb_release -d -s`
IMAGE_FILE=$DEST_PATH/${OS_D// /}_HW_${STORE_FS_TYPE}_$CURDATE.img
TEMP_MOUNT_POINT=`mktemp -d -p $DEST_PATH`

set -e
trap finish ERR INT

if [[ $STORE_FS_TYPE == "btrfs" ]]; then
	truncate -s ${IMAGE_SIZE}M $IMAGE_FILE
    mkfs.btrfs -fq -L rootfs $IMAGE_FILE
    mount -t btrfs -o noatime,compress=lzo $IMAGE_FILE $TEMP_MOUNT_POINT
    btrfs subvolume create $TEMP_MOUNT_POINT/root
	umount $TEMP_MOUNT_POINT
    mount -t btrfs -o noatime,compress=lzo,subvol=root $IMAGE_FILE $TEMP_MOUNT_POINT
else
	INODE_COUNT=$(find "${ROOTFS_MOUNTPOINT}" 2>/dev/null | wc -l)
	INODE_COUNT=$((INODE_COUNT+512))
	BLOCK_COUNT=$(((ROOTFS_SIZE+INODE_COUNT/4)*15/10))

	mkfs.ext4 -Fq -L rootfs -b 1024 -I 128 -N $INODE_COUNT $IMAGE_FILE $BLOCK_COUNT
	mount $IMAGE_FILE $TEMP_MOUNT_POINT
fi

echo "sync..."
rsync -aqx --delete --exclude={"$IMAGE_FILE","$TEMP_MOUNT_POINT"} ${ROOTFS_MOUNTPOINT}/ ${TEMP_MOUNT_POINT}/
echo "sync finish"

set +e
trap - ERR

clead_target_rootfs ${TEMP_MOUNT_POINT}
umount_img

if [[ "${STORE_FS_TYPE}" == "ext4" ]]; then
	e2fsck -fy ${IMAGE_FILE} 2>&1 > /dev/null
	resize2fs -M ${IMAGE_FILE} 2>&1 > /dev/null
    tune2fs -C 1 -c 0 -i 0 -e "remount-ro" ${IMAGE_FILE} 2>&1 > /dev/null
fi
echo -e "\033[31m Export rootfs to $IMAGE_FILE Success \033[0m"
